<!DOCTYPE html>
<html>
<head>
    <title>Shambles : Battle Sim</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        #gridPreview {
            position: fixed;
            bottom: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
        }
        .team-controls {
            margin: 10px 0;
        }
        button {
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
        }
        #instructions {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
        }
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            z-index: 1000;
        }
        .modal h2 {
            margin-top: 0;
            color: #fff;
        }
        .modal button {
            margin: 10px;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
        }
        .modal button:hover {
            background: #45a049;
        }
        .modal input {
            margin: 10px;
            padding: 5px;
            width: 200px;
        }
        #endScreen {
            font-size: 24px;
            font-weight: bold;
        }
        .battle-controls {
            margin-top: 10px;
            display: flex;
            gap: 5px;
        }
        #renameButton {
            margin-left: 5px;
            padding: 2px 5px;
            font-size: 0.9em;
        }
        #newTeamName {
            margin: 10px;
            padding: 5px;
            width: 200px;
        }
        .blood-splatter {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 0, 0, 0.7);
            border-radius: 50%;
            pointer-events: none;
        }
        #killFeed {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 200px; /* reduced from 300px */
            max-height: 40vh; /* reduced from 80vh */
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px;
            border-radius: 5px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(255,255,255,0.3) transparent;
        }
        #killFeed::-webkit-scrollbar {
            width: 6px;
        }
        #killFeed::-webkit-scrollbar-thumb {
            background-color: rgba(255,255,255,0.3);
            border-radius: 3px;
        }
        .blood-decal {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            #gridPreview, #instructions {
                display: none;
            }
            
            #controls {
                bottom: 10px;
                top: auto;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-width: 400px;
                display: flex;
                flex-direction: column;
                align-items: center;
                z-index: 1000;
            }
            
            .battle-controls {
                width: 100%;
                justify-content: space-around;
            }
            
            #killFeed {
                width: 90%;
                max-width: 400px;
                left: 50%;
                transform: translateX(-50%);
                max-height: 20vh;
            }
            
            #teamSelect {
                width: 100%;
                padding: 8px;
                margin: 5px 0;
            }
            
            #unitCount {
                width: 100% !important;
                padding: 8px;
                margin: 5px 0;
            }
            
            button {
                padding: 10px !important;
                min-width: 80px;
            }

            input, select {
                font-size: 16px !important; /* Prevent iOS zoom */
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <div style="display: flex; align-items: center; justify-content: space-between; width: 100%;">
            <div style="display: flex; align-items: center;">
                <label>Current Team:</label>
                <select id="teamSelect" onchange="handleTeamSelect()">
                    <option value="0">Red Team</option>
                    <option value="1">Blue Team</option>
                    <option value="portal">VibeVerse Portal</option>
                </select>
                <button onclick="showRenameTeamDialog()" id="renameButton">Rename Team</button>
            </div>
            <button onclick="toggleMusic()" id="musicButton">üîä Music On</button>
        </div>
        <div>
            <label>Number of Units:</label>
            <input type="number" id="unitCount" value="1" min="1" max="1000" style="width: 60px;" onchange="this.blur()">
        </div>
        <div class="battle-controls">
            <button onclick="startBattle()" id="startButton">Start Battle</button>
            <button onclick="stopBattle()" id="stopButton" disabled>Stop Battle</button>
            <button onclick="resetBattle()" id="resetButton">Reset All</button>
            <button onclick="resetTeam()" id="resetTeamButton">Reset Selected Team</button>
        </div>
    </div>

    <div id="renameTeamDialog" class="modal">
        <h2>Rename Team</h2>
        <input type="text" id="newTeamName" placeholder="Enter new team name">
        <div>
            <button onclick="renameTeam()">Save</button>
            <button onclick="closeRenameDialog()">Cancel</button>
        </div>
    </div>

    <div id="endScreen" class="modal">
        <h2 id="endScreenTitle"></h2>
        <button onclick="closeEndScreen()">Continue</button>
    </div>

    <div id="instructions">
        Controls:<br>
        - Spacebar: Place Units at Mouse Position<br>
        - WASD: Move Camera Position<br>
        - Right Click + Drag: Rotate Camera<br>
        - Middle Click + Drag: Pan<br>
        - Scroll: Zoom<br>
        - Place two teams and a portal to enter the vibeverse
    </div>
    <div id="gridPreview"></div>
    <div id="killFeed"></div>
    
    <!-- Add Vibe Jam Link -->
    <a target="_blank" href="https://jam.pieter.com" style="font-family: 'system-ui', sans-serif; position: fixed; bottom: -1px; right: -1px; padding: 7px; font-size: 14px; font-weight: bold; background: #fff; color: #000; text-decoration: none; z-index: 10; border-top-left-radius: 12px; z-index: 10000; border: 1px solid #fff;">üïπÔ∏è Vibe Jam 2025</a>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script>
        // Fetch environment variables from server
        async function getEnvConfig() {
            const response = await fetch('/env-config');
            const config = await response.json();
            return config;
        }

        // Initialize environment variables before starting the game
        async function initializeEnv() {
            const config = await getEnvConfig();
            window.GROQ_API_KEY = config.GROQ_API_KEY;
            window.PEXELS_API_KEY = config.PEXELS_API_KEY;
            init(); // Call your existing init function
        }

        let scene, camera, renderer, ground, controls;
        let units = [];
        let isSimulating = false;
        let gridHelper, raycaster, mouse;
        let initialPositions = new Map(); // Store initial positions of units
        const teamNames = ['Red Team', 'Blue Team'];
        const teamColors = [0xff0000, 0x0000ff];
        const GROUND_SIZE = 1000; // Increased from 500
        const GRID_DIVISIONS = 50; // More grid divisions for larger ground
        let clouds = []; // Add array for clouds

        // Movement controls
        const moveSpeed = 5.0; // Increased from 1.0
        const keysPressed = {
            w: false,
            a: false,
            s: false,
            d: false
        };

        let battleLore = null;
        let lastLoreTime = 0;
        const LORE_MESSAGE_DELAY = 3000; // 3 seconds between messages

        let simulationSpeed = 0.5; // Slower simulation for better lore sync
        let deadUnits = []; // Track dying units for physics
        const DEATH_ANIMATION_DURATION = 2000;

        let bloodDecals = [];
        let conversationId = Date.now();

        const textureLoader = new THREE.TextureLoader();
        let groundTexture;

        const PARTICLE_COUNT = 50;
        let particles = [];

        const MIN_Y_POSITION = 2; // Minimum height for units
        const THUNDER_CHANCE = 0.01; // 1% chance per frame for thunder
        let lastThunderTime = 0;
        const THUNDER_COOLDOWN = 2000; // 2 seconds between thunder strikes

        let isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

        // Add after other constants
        let unitTextures = new Map(); // Store textures for each team

        // Add after other global variables
        const CALM_MUSIC_URL = 'https://cdn.glitch.global/5c9e14cb-9394-4f13-bc2d-9950af300b7f/Calm%20before%20the%20storm%20.mp3?v=1743302231480';
        const BATTLE_MUSIC_URL = 'https://cdn.glitch.global/5c9e14cb-9394-4f13-bc2d-9950af300b7f/The%20Siege.mp3?v=1743302235123';
        let calmMusic, battleMusic;
        let portalMesh = null;

        // Load textures
        function loadTextures() {
            return new Promise((resolve, reject) => {
                let loadedCount = 0;
                const totalTextures = 1;

                function checkLoaded() {
                    loadedCount++;
                    if (loadedCount === totalTextures) resolve();
                }

                groundTexture = textureLoader.load('https://cdn.glitch.global/5c9e14cb-9394-4f13-bc2d-9950af300b7f/Grass%207.png?v=1743482683674', checkLoaded);
                
                // Restore grass texture repetition
                groundTexture.wrapS = THREE.RepeatWrapping;
                groundTexture.wrapT = THREE.RepeatWrapping;
                groundTexture.repeat.set(20, 20);
            });
        }

        async function getTeamTexture(teamName) {
            try {
                console.log(`Fetching texture for team: ${teamName}`);
                const response = await fetch(`https://api.pexels.com/v1/search?query=${teamName}&per_page=1`, {
                    headers: {
                        'Authorization': window.PEXELS_API_KEY
                    }
                });
                const data = await response.json();
                
                if (data.photos && data.photos.length > 0) {
                    const imageUrl = data.photos[0].src.medium;
                    console.log(`Found image URL: ${imageUrl}`);
                    return new Promise((resolve) => {
                        textureLoader.load(imageUrl, (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            console.log(`Texture loaded successfully for ${teamName}`);
                            resolve(texture);
                        });
                    });
                }
                console.log(`No images found for ${teamName}`);
                return null;
            } catch (error) {
                console.error('Pexels API Error:', error);
                return null;
            }
        }

        async function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Add light blue sky color
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Wait for textures to load
            await loadTextures();

            // Create ground with texture
            const groundGeometry = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE);
            const groundMaterial = new THREE.MeshStandardMaterial({ 
                map: groundTexture,
                roughness: 0.8,
                metalness: 0.2
            });
            ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(0, 20, 0);
            scene.add(directionalLight);

            // Add grid helper
            gridHelper = new THREE.GridHelper(GROUND_SIZE, GRID_DIVISIONS, 0x000000, 0x404040);
            scene.add(gridHelper);

            // Replace cloud creation code with 3D clouds
            function create3DCloud() {
                const cloudGroup = new THREE.Group();
                const cloudMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.6
                });

                // Create multiple spheres for volumetric cloud
                const sphereCounts = 8;
                for(let i = 0; i < sphereCounts; i++) {
                    const size = 15 + Math.random() * 10;
                    const geometry = new THREE.SphereGeometry(size, 8, 8);
                    const cloudPiece = new THREE.Mesh(geometry, cloudMaterial);
                    
                    // Distribute spheres in a clump
                    cloudPiece.position.set(
                        (Math.random() - 0.5) * 30,
                        (Math.random() - 0.5) * 15,
                        (Math.random() - 0.5) * 30
                    );
                    cloudGroup.add(cloudPiece);
                }

                return cloudGroup;
            }

            // Create vegetation
            function createTree(position) {
                const tree = new THREE.Group();
                
                // Trunk
                const trunkGeometry = new THREE.CylinderGeometry(1, 1.5, 8, 8);
                const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = 4;
                tree.add(trunk);
                
                // Leaves (using grass texture)
                const leavesGeometry = new THREE.ConeGeometry(5, 10, 8);
                const leavesMaterial = new THREE.MeshStandardMaterial({ 
                    map: groundTexture,
                    color: 0x355E3B
                });
                const leaves = new THREE.Mesh(leavesGeometry, leavesMaterial);
                leaves.position.y = 11;
                tree.add(leaves);
                
                tree.position.copy(position);
                return tree;
            }

            function createBush(position) {
                const bushGeometry = new THREE.SphereGeometry(2, 8, 8);
                const bushMaterial = new THREE.MeshStandardMaterial({ 
                    map: groundTexture,
                    color: 0x355E3B
                });
                const bush = new THREE.Mesh(bushGeometry, bushMaterial);
                bush.position.copy(position);
                bush.position.y = 2;
                return bush;
            }

            // Add vegetation randomly around the map
            const vegetationCount = 100;
            for(let i = 0; i < vegetationCount; i++) {
                const position = new THREE.Vector3(
                    (Math.random() - 0.5) * (GROUND_SIZE - 50),
                    0,
                    (Math.random() - 0.5) * (GROUND_SIZE - 50)
                );
                
                if(Math.random() > 0.7) {
                    scene.add(createTree(position));
                } else {
                    scene.add(createBush(position));
                }
            }

            // Create more 3D clouds at adjusted height
            clouds = [];
            const cloudCount = 40; // Increased count
            for(let i = 0; i < cloudCount; i++) {
                const cloud = create3DCloud();
                cloud.position.set(
                    (Math.random() - 0.5) * GROUND_SIZE,
                    100 + Math.random() * 30, // Lower height (100-130 units)
                    (Math.random() - 0.5) * GROUND_SIZE
                );
                scene.add(cloud);
                clouds.push(cloud);
            }

            // Setup camera and controls differently for mobile
            if (isMobile) {
                camera.position.set(0, 100, 0); // Top-down view
                camera.lookAt(0, 0, 0);
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableRotate = false; // Disable rotation on mobile
                controls.enableZoom = true;
                controls.maxPolarAngle = 0; // Force top-down view
                controls.minPolarAngle = 0;
            } else {
                camera.position.set(0, 40, 80);
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.maxPolarAngle = Math.PI / 2;
            }

            // Setup raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Only setup preview renderer for desktop
            if (!isMobile) {
                setupPreviewRenderer();
            }

            // Add event listeners based on device
            if (isMobile) {
                window.addEventListener('touchstart', onMobileTouch);
            } else {
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('keydown', onKeyDown);
                window.addEventListener('keyup', onKeyUp);
            }

            // Setup music after scene is ready
            setupMusic();

            animate();
        }

        let previewRenderer, previewScene, previewCamera;
        function setupPreviewRenderer() {
            const previewContainer = document.getElementById('gridPreview');
            previewScene = new THREE.Scene();
            previewCamera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            previewRenderer = new THREE.WebGLRenderer({ antialias: true });
            previewRenderer.setSize(200, 200);
            previewContainer.appendChild(previewRenderer.domElement);

            // Add preview lighting
            const previewLight = new THREE.AmbientLight(0xffffff);
            previewScene.add(previewLight);

            previewCamera.position.set(0, 30, 30);
            previewCamera.lookAt(0, 0, 0);
        }

        function setupMusic() {
            calmMusic = new Audio(CALM_MUSIC_URL);
            battleMusic = new Audio(BATTLE_MUSIC_URL);
            
            calmMusic.loop = true;
            battleMusic.loop = true;
            
            // Start with music off
            document.getElementById('musicButton').textContent = 'üîá Play Music';
        }

        function toggleMusic() {
            const button = document.getElementById('musicButton');
            if (calmMusic.paused) {
                calmMusic.play();
                button.textContent = 'üîä Music On';
            } else {
                calmMusic.pause();
                battleMusic.pause();
                button.textContent = 'üîá Play Music';
            }
        }

        function handleTeamSelect() {
            const select = document.getElementById('teamSelect');
            const unitCount = document.getElementById('unitCount');
            
            if (select.value === 'portal') {
                unitCount.value = '1';
                unitCount.disabled = true;
            } else {
                unitCount.disabled = false;
            }
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onMobileTouch(event) {
            // Don't prevent default for buttons and inputs
            if (event.target.tagName === 'BUTTON' || 
                event.target.tagName === 'INPUT' || 
                event.target.tagName === 'SELECT') {
                return;
            }

            if (!isSimulating) {
                event.preventDefault();
                const touch = event.touches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                placeUnits();
            }
        }

        function onKeyDown(event) {
            // Check if we're typing in an input field
            const isTyping = document.activeElement.tagName === 'INPUT' || 
                           document.activeElement.tagName === 'TEXTAREA';

            // If typing, only handle Enter key to blur the input
            if (isTyping) {
                if (event.key === 'Enter') {
                    document.activeElement.blur();
                }
                return;
            }

            // Only handle game controls if not typing
            switch(event.code) {
                case 'Space':
                    if (!isSimulating) {
                        event.preventDefault();
                        placeUnits();
                    }
                    break;
                case 'KeyW': keysPressed.w = true; break;
                case 'KeyA': keysPressed.a = true; break;
                case 'KeyS': keysPressed.s = true; break;
                case 'KeyD': keysPressed.d = true; break;
            }
        }

        function onKeyUp(event) {
            // Only handle game controls if not typing
            if (document.activeElement.tagName !== 'INPUT' && 
                document.activeElement.tagName !== 'TEXTAREA') {
                switch(event.code) {
                    case 'KeyW': keysPressed.w = false; break;
                    case 'KeyA': keysPressed.a = false; break;
                    case 'KeyS': keysPressed.s = false; break;
                    case 'KeyD': keysPressed.d = false; break;
                }
            }
        }

        function updateCameraPosition() {
            // Only update camera if not typing
            if (document.activeElement.tagName === 'INPUT' || 
                document.activeElement.tagName === 'TEXTAREA') {
                return;
            }

            // Get camera's forward and right vectors
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);
            
            // Rotate vectors based on camera rotation
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);
            
            // Zero out y component to keep movement horizontal
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();
            
            // Calculate movement based on keys pressed
            const movement = new THREE.Vector3(0, 0, 0);
            
            if (keysPressed.w) movement.add(forward.multiplyScalar(moveSpeed));
            if (keysPressed.s) movement.sub(forward.multiplyScalar(moveSpeed));
            if (keysPressed.d) movement.add(right.multiplyScalar(moveSpeed));
            if (keysPressed.a) movement.sub(right.multiplyScalar(moveSpeed));
            
            // Apply movement to camera position
            camera.position.add(movement);
            
            // Update OrbitControls target to maintain relative position
            controls.target.add(movement);
        }

        function placeUnits() {
            if (!isSimulating) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(ground);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const teamSelect = document.getElementById('teamSelect');
                    
                    // Handle portal placement
                    if (teamSelect.value === 'portal') {
                        if (portalMesh) portalMesh.remove();
                        portalMesh = new VibeVersePortal(point);
                        return;
                    }

                    // Normal unit placement
                    const team = parseInt(teamSelect.value);
                    const count = parseInt(document.getElementById('unitCount').value);
                    
                    // Calculate grid dimensions for placement
                    const gridCols = Math.ceil(Math.sqrt(count));
                    const gridRows = Math.ceil(count / gridCols);
                    const spacing = isMobile ? 3 : 4; // Space between units
                    
                    // Calculate starting position to center the grid
                    const startX = point.x - (gridCols - 1) * spacing / 2;
                    const startZ = point.z - (gridRows - 1) * spacing / 2;
                    
                    // Place units in a grid formation
                    let unitsPlaced = 0;
                    for (let row = 0; row < gridRows && unitsPlaced < count; row++) {
                        for (let col = 0; col < gridCols && unitsPlaced < count; col++) {
                            const x = startX + col * spacing;
                            const z = startZ + row * spacing;
                            const unit = new Unit(team, new THREE.Vector3(x, 2, z));
                            units.push(unit);
                            unitsPlaced++;
                        }
                    }
                    updatePreview();
                }
            }
        }

        class Unit {
            constructor(team, position) {
                const geometry = new THREE.BoxGeometry(4, 4, 4); // Increased from 3,3,3
                const material = new THREE.MeshStandardMaterial({ color: teamColors[team] });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.position.y = 2;
                this.team = team;
                this.health = 100;
                this.target = null;
                this.speed = 0.2;
                scene.add(this.mesh);

                // Add preview unit
                if (!isMobile) {
                    const previewMesh = this.mesh.clone();
                    previewMesh.scale.set(0.5, 0.5, 0.5);
                    previewScene.add(previewMesh);
                    this.previewMesh = previewMesh;
                }
            }

            update() {
                if (!isSimulating) return; // Don't update if battle isn't running
                
                if (!this.target && this.health > 0) {
                    this.findTarget();
                }
                if (this.target && this.target.health > 0) {
                    const direction = new THREE.Vector3()
                        .subVectors(this.target.mesh.position, this.mesh.position)
                        .normalize();
                    const newPosition = this.mesh.position.clone()
                        .add(direction.multiplyScalar(this.speed));
                    
                    // Ensure minimum Y position
                    newPosition.y = Math.max(MIN_Y_POSITION, newPosition.y);
                    this.mesh.position.copy(newPosition);
                    
                    this.mesh.lookAt(this.target.mesh.position);

                    if (this.mesh.position.distanceTo(this.target.mesh.position) < 3) {
                        this.attack();
                    }
                }

                // Keep unit above ground
                if (this.mesh.position.y < MIN_Y_POSITION) {
                    this.mesh.position.y = MIN_Y_POSITION;
                }
            }

            findTarget() {
                if (!isSimulating) return; // Don't find targets if battle isn't running
                const enemies = units.filter(u => 
                    u.team !== this.team && // Must be different team
                    u.health > 0 && // Must be alive
                    isSimulating // Must be during battle
                );
                if (enemies.length > 0) {
                    this.target = enemies[Math.floor(Math.random() * enemies.length)];
                }
            }

            attack() {
                if (this.target) {
                    this.target.health -= Math.random() * 20;
                    
                    // Add battle effects
                    if (Math.random() < 0.3) {
                        createBattleEffects(this.mesh.position);
                        if (Math.random() < 0.2) { // 20% chance for explosion on hit
                            createExplosion(this.mesh.position);
                        }
                    }
                    
                    if (this.target.health <= 0) {
                        createExplosion(this.target.mesh.position); // Always explode on death
                        this.killUnit(this.target);
                        this.target = null;
                    }
                }
            }

            killUnit(target) {
                const force = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2 + 1,
                    (Math.random() - 0.5) * 2
                );
                
                target.mesh.userData.velocity = force;
                target.mesh.userData.rotationVel = new THREE.Vector3(
                    Math.random() * 0.2,
                    Math.random() * 0.2,
                    Math.random() * 0.2
                );
                
                deadUnits.push({
                    mesh: target.mesh,
                    startTime: Date.now(),
                    initialPos: target.mesh.position.clone()
                });

                // Create blood on ground where unit died
                createBloodSplatter(target.mesh.position);
                
                if (!isMobile) {
                    previewScene.remove(target.previewMesh);
                }
            }
        }

        class VibeVersePortal {
            constructor(position) {
                const geometry = new THREE.TorusGeometry(3, 0.5, 16, 100);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00ff00,
                    emissive: 0x00ff00,
                    emissiveIntensity: 0.5,
                    transparent: true,
                    opacity: 0.8
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(position);
                this.mesh.position.y = 2;
                this.mesh.rotation.x = Math.PI / 2;
                
                // Add spinning animation
                this.mesh.userData.rotationSpeed = 0.02;
                scene.add(this.mesh);
                
                // Create portal effect
                const particleGeometry = new THREE.BufferGeometry();
                const particleCount = 100;
                const positions = new Float32Array(particleCount * 3);
                
                for(let i = 0; i < particleCount * 3; i += 3) {
                    const angle = (Math.random() * Math.PI * 2);
                    const radius = 3 + Math.random() * 0.5;
                    positions[i] = Math.cos(angle) * radius;
                    positions[i + 1] = Math.random() * 4;
                    positions[i + 2] = Math.sin(angle) * radius;
                }
                
                particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                const particleMaterial = new THREE.PointsMaterial({
                    color: 0x00ff00,
                    size: 0.1,
                    transparent: true,
                    opacity: 0.6
                });
                
                this.particles = new THREE.Points(particleGeometry, particleMaterial);
                this.particles.position.copy(position);
                scene.add(this.particles);
            }

            update() {
                this.mesh.rotation.z += this.mesh.userData.rotationSpeed;
                this.particles.rotation.y += 0.01;
            }

            remove() {
                scene.remove(this.mesh);
                scene.remove(this.particles);
            }
        }

        function createBloodSplatter(position) {
            // Create multiple blood decals for more gore
            const decalCount = Math.floor(Math.random() * 3) + 3; // 3-5 decals per death
            
            for (let i = 0; i < decalCount; i++) {
                const spread = 2; // Spread radius
                const randomX = position.x + (Math.random() - 0.5) * spread;
                const randomZ = position.z + (Math.random() - 0.5) * spread;
                
                const decalGeometry = new THREE.CircleGeometry(Math.random() * 1.5 + 0.5, 8);
                const decalMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(
                        0.4 + Math.random() * 0.2, // Vary the red component
                        0,
                        0
                    ),
                    transparent: true,
                    opacity: 0.7,
                    depthWrite: false
                });
                
                const decal = new THREE.Mesh(decalGeometry, decalMaterial);
                decal.rotation.x = -Math.PI / 2;
                decal.rotation.z = Math.random() * Math.PI; // Random rotation
                decal.position.set(randomX, 0.01, randomZ);
                scene.add(decal);
                bloodDecals.push(decal);
            }
            
            // Don't remove the blood decals automatically
            // They'll stay until reset
        }

        function createBattleEffects(position) {
            // Create fire particle
            const fireGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const fireMaterial = new THREE.MeshBasicMaterial({
                color: new THREE.Color(Math.random() < 0.5 ? 0xff4400 : 0xff8800),
                transparent: true,
                opacity: 0.7
            });
            const fire = new THREE.Mesh(fireGeometry, fireMaterial);
            
            // Random position around battle area
            const radius = Math.random() * 5;
            const angle = Math.random() * Math.PI * 2;
            fire.position.set(
                position.x + Math.cos(angle) * radius,
                position.y + Math.random() * 2,
                position.z + Math.sin(angle) * radius
            );
            
            // Add velocity and life properties
            fire.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.1,
                Math.random() * 0.2,
                (Math.random() - 0.5) * 0.1
            );
            fire.userData.life = 1.0;
            
            scene.add(fire);
            particles.push(fire);
        }

        function createThunderEffect(position) {
            // Create lightning bolt
            const thunderGeometry = new THREE.CylinderGeometry(0.1, 0.1, 20, 8);
            const thunderMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFFFF,
                transparent: true,
                opacity: 0.8
            });
            const thunder = new THREE.Mesh(thunderGeometry, thunderMaterial);
            thunder.position.copy(position);
            thunder.position.y = 15; // Start from above
            scene.add(thunder);

            // Add flash light
            const flashLight = new THREE.PointLight(0x4444ff, 2, 20);
            flashLight.position.copy(thunder.position);
            scene.add(flashLight);

            // Create explosion at impact
            createExplosion(position);

            // Remove after short duration
            setTimeout(() => {
                scene.remove(thunder);
                scene.remove(flashLight);
            }, 150);
        }

        function createExplosion(position) {
            const particleCount = 20;
            const colors = [0xff4400, 0xff8800, 0xffff00];
            
            for (let i = 0; i < particleCount; i++) {
                const size = Math.random() * 0.5 + 0.5;
                const geometry = new THREE.SphereGeometry(size, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: colors[Math.floor(Math.random() * colors.length)],
                    transparent: true,
                    opacity: 0.8
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                
                // Explosive velocity
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 0.5 + 0.5;
                particle.userData.velocity = new THREE.Vector3(
                    Math.cos(angle) * speed,
                    Math.random() * speed * 2,
                    Math.sin(angle) * speed
                );
                particle.userData.life = 1.0;
                
                scene.add(particle);
                particles.push(particle);
            }
        }

        async function getBattleLore(activeTeams) {
            // Add validation for active teams
            if (activeTeams.length < 2 || !activeTeams.every(team => team.count > 0)) {
                console.error('Invalid team state for lore generation');
                return null;
            }

            try {
                const teamsInfo = activeTeams
                    .map(team => `${team.name} (${team.count} units)`)
                    .join(' vs ');
                
                const prompt = `Write TWO very short sentences (max 25 words) about a battle moment between ${teamsInfo}. Important rules:
                1. Must start with winning team name
                2. Must be short and concise
                3. Must be lore accurate ( One sentence for the battle and One sentence for the lore)
                4. Format: "[Team Name] defeats [other team] with [brief action]."`;
                
                const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${window.GROQ_API_KEY}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        messages: [
                            { 
                                role: 'system', 
                                content: 'You are a battle narrator. Keep responses extremely short and clear.' 
                            },
                            { role: 'user', content: prompt }
                        ],
                        model: 'llama3-8b-8192',
                        temperature: 0.7,
                        max_tokens: 50
                    })
                });

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('GROQ API Error:', error);
                return null;
            }
        }

        async function startBattle() {
            // Remove any focus from buttons/inputs
            if (document.activeElement) {
                document.activeElement.blur();
            }

            // Check for portal first - if portal exists, it takes priority
            if (portalMesh) {
                isSimulating = true;
                document.getElementById('startButton').disabled = true;
                document.getElementById('stopButton').disabled = true;
                gridHelper.visible = false;

                // Stop all units from fighting
                units.forEach(unit => {
                    unit.findTarget = () => {};
                    unit.attack = () => {};
                    // Ensure units maintain minimum height
                    unit.mesh.position.y = Math.max(MIN_Y_POSITION, unit.mesh.position.y);
                });

                // Create portal effect light
                const portalLight = new THREE.PointLight(0x00ff00, 2, 20);
                portalLight.position.copy(portalMesh.mesh.position);
                scene.add(portalLight);

                // Stop any playing music
                calmMusic.pause();
                battleMusic.pause();

                // Replace the animateUnits function in startBattle with this version:
                const animateUnits = () => {
                    let allUnitsInPortal = true;

                    units.forEach(unit => {
                        const direction = new THREE.Vector3().subVectors(portalMesh.mesh.position, unit.mesh.position);
                        direction.y = 0; // Keep horizontal movement only
                        const distance = direction.length();

                        if (distance > 0.2) {
                            allUnitsInPortal = false;
                            direction.normalize();
                            
                            // Move horizontally first
                            unit.mesh.position.add(direction.multiplyScalar(0.2));
                            
                            // Only start shrinking when very close to portal
                            if (distance < 2) {
                                // Calculate shrink factor based on distance
                                const shrinkFactor = Math.max(0.95, distance / 2);
                                unit.mesh.scale.multiplyScalar(shrinkFactor);
                                
                                // Float up slightly as they enter portal
                                const heightAdjust = Math.min(2, 3 * (1 - distance / 2));
                                unit.mesh.position.y = MIN_Y_POSITION + heightAdjust;
                            } else {
                                // Maintain normal height while approaching
                                unit.mesh.position.y = MIN_Y_POSITION;
                            }
                            
                            // Spin faster as they get closer
                            const spinSpeed = Math.min(0.4, 0.2 + (2 - distance) * 0.1);
                            unit.mesh.rotation.y += spinSpeed;

                            // Add more particle effects when close
                            if (distance < 3 && Math.random() < 0.3) {
                                const particle = new THREE.Mesh(
                                    new THREE.SphereGeometry(0.1, 8, 8),
                                    new THREE.MeshBasicMaterial({
                                        color: 0x00ff00,
                                        transparent: true,
                                        opacity: 0.5
                                    })
                                );
                                particle.position.copy(unit.mesh.position);
                                particle.userData.velocity = new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.1,
                                    Math.random() * 0.1,
                                    (Math.random() - 0.5) * 0.1
                                );
                                particle.userData.life = 1.0;
                                scene.add(particle);
                                particles.push(particle);
                            }
                        }
                    });

                    if (allUnitsInPortal) {
                        // Create flash effect
                        const flash = new THREE.PointLight(0x00ff00, 10, 100);
                        flash.position.copy(portalMesh.mesh.position);
                        scene.add(flash);

                        // Cleanup
                        scene.remove(portalLight);

                        // Redirect after short delay
                        setTimeout(() => {
                            window.location.href = 'http://portal.pieter.com';
                        }, 300);
                    } else {
                        requestAnimationFrame(animateUnits);
                    }
                };

                animateUnits();
                return;
            }

            if (units.length < 2) {
                showEndScreen('Not Enough Units', 'Add at least 2 units to start a battle!');
                return;
            }

            // Get active teams before anything else
            const teamCounts = {};
            units.forEach(unit => {
                teamCounts[teamNames[unit.team]] = (teamCounts[teamNames[unit.team]] || 0) + 1;
            });

            // Verify we have at least 2 teams with units
            const activeTeams = Object.entries(teamCounts).map(([name, count]) => ({
                name,
                count,
                index: teamNames.indexOf(name)
            })).filter(team => team.count > 0);

            if (activeTeams.length < 2) {
                showEndScreen('Not Enough Teams', 'Need units from at least 2 different teams!');
                return;
            }

            // Hide grid when battle starts
            gridHelper.visible = false;

            // Clear previous state
            deadUnits = [];
            bloodDecals.forEach(decal => scene.remove(decal));
            bloodDecals = [];
            document.getElementById('killFeed').innerHTML = '';

            // Clear any existing particles
            particles.forEach(particle => scene.remove(particle));
            particles = [];

            // Fetch textures for both teams before starting
            for (let team of activeTeams) {
                if (!unitTextures.has(team.name)) {
                    const texture = await getTeamTexture(team.name);
                    if (texture) {
                        unitTextures.set(team.name, texture);
                    }
                }
            }

            // Apply textures to all units
            units.forEach(unit => {
                const teamName = teamNames[unit.team];
                const texture = unitTextures.get(teamName);
                
                if (texture) {
                    // Create materials for each side
                    const materials = [];
                    for (let i = 0; i < 6; i++) {
                        if (!isMobile && i === 1) { // Top face (index 1 in BoxGeometry)
                            materials.push(new THREE.MeshStandardMaterial({ 
                                color: teamColors[unit.team],
                                metalness: 0.5,
                                roughness: 0.5
                            }));
                        } else {
                            // Make textures more visible
                            materials.push(new THREE.MeshStandardMaterial({ 
                                map: texture,
                                metalness: 0.3,
                                roughness: 0.4,
                                emissive: new THREE.Color(0x222222) // Slight glow
                            }));
                        }
                    }
                    unit.mesh.material = materials;
                }
            });

            // Get initial battle lore with verified teams
            const initialLore = await getBattleLore(activeTeams);
            if (!initialLore) return;

            // Modified team name matching logic
            const loreParts = initialLore.split(' defeats ');
            const winningTeamName = loreParts[0].trim();
            
            // Find winning team by comparing names case-insensitively
            const winningTeam = activeTeams.find(t => 
                t.name.toLowerCase() === winningTeamName.toLowerCase() ||
                winningTeamName.toLowerCase().includes(t.name.toLowerCase()) ||
                t.name.toLowerCase().includes(winningTeamName.toLowerCase())
            );

            if (!winningTeam) {
                // Fallback: just pick the first team if name matching fails
                console.warn('Could not match winning team name, using fallback');
                const randomIndex = Math.floor(Math.random() * activeTeams.length);
                window.predeterminedWinner = activeTeams[randomIndex].index;
            } else {
                window.predeterminedWinner = winningTeam.index;
            }

            // Buff/debuff based on predetermined winner
            units.forEach(unit => {
                if (unit.team === window.predeterminedWinner) {
                    unit.health = 200;
                    unit.speed *= 1.5;
                } else {
                    unit.health = 40;
                    unit.speed *= 0.6;
                }
            });

            // Store initial positions and start battle
            initialPositions.clear();
            units.forEach(unit => {
                initialPositions.set(unit, unit.mesh.position.clone());
            });

            // Display initial lore
            const killFeed = document.getElementById('killFeed');
            const message = document.createElement('div');
            message.className = 'kill-message';
            message.textContent = initialLore;
            killFeed.appendChild(message);

            isSimulating = true;
            document.getElementById('startButton').disabled = true;
            document.getElementById('stopButton').disabled = false;

            // Switch music with crossfade
            if (calmMusic && battleMusic) {
                const fadeOut = setInterval(() => {
                    if (calmMusic.volume <= 0.1) {
                        clearInterval(fadeOut);
                        calmMusic.pause();
                    } else {
                        calmMusic.volume -= 0.1;
                    }
                }, 50);

                battleMusic.volume = 0;
                battleMusic.play();
                const fadeIn = setInterval(() => {
                    if (battleMusic.volume >= 0.9) {
                        clearInterval(fadeIn);
                        battleMusic.volume = 1;
                    } else {
                        battleMusic.volume += 0.1;
                    }
                }, 50);
            }
        }

        function fadeOutMusic(audio, callback) {
            if (!audio || audio.paused) {
                if (callback) callback();
                return;
            }
            
            const fadeInterval = setInterval(() => {
                if (audio.volume <= 0.05) {
                    clearInterval(fadeInterval);
                    if (callback) callback();
                } else {
                    audio.volume = Math.max(0, audio.volume - 0.05);
                }
            }, 50);
        }

        function updatePreview() {
            if (isMobile) return; // Skip on mobile
            units.forEach((unit, index) => {
                const previewPos = new THREE.Vector3()
                    .copy(unit.mesh.position)
                    .multiplyScalar(0.2);
                unit.previewMesh.position.copy(previewPos);
            });
        }

        function showRenameTeamDialog() {
            const teamSelect = document.getElementById('teamSelect');
            const currentTeam = teamSelect.value;
            const dialog = document.getElementById('renameTeamDialog');
            const input = document.getElementById('newTeamName');
            input.value = teamNames[currentTeam];
            dialog.style.display = 'block';
            input.focus();
        }

        function closeRenameDialog() {
            document.getElementById('renameTeamDialog').style.display = 'none';
        }

        function renameTeam() {
            const teamSelect = document.getElementById('teamSelect');
            const currentTeam = parseInt(teamSelect.value);
            const newName = document.getElementById('newTeamName').value.trim();
            
            if (newName) {
                teamNames[currentTeam] = newName;
                teamSelect.options[currentTeam].text = newName;
                closeRenameDialog();
            }
        }

        function stopBattle() {
            isSimulating = false;
            document.getElementById('startButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
            gridHelper.visible = true;
            
            // Switch back to calm music and ensure it plays
            if (calmMusic && battleMusic) {
                const fadeOut = setInterval(() => {
                    if (battleMusic.volume <= 0.1) {
                        clearInterval(fadeOut);
                        battleMusic.pause();
                        battleMusic.currentTime = 0;
                    } else {
                        battleMusic.volume -= 0.1;
                    }
                }, 50);

                calmMusic.volume = 0;
                calmMusic.currentTime = 0;
                calmMusic.play();
                const fadeIn = setInterval(() => {
                    if (calmMusic.volume >= 0.9) {
                        clearInterval(fadeIn);
                        calmMusic.volume = 1;
                    } else {
                        calmMusic.volume += 0.1;
                    }
                }, 50);
            }
            
            // Clear everything except blood decals
            clearBattleField();
        }

        function clearBattleField() {
            // Remove all units
            units.forEach(unit => {
                scene.remove(unit.mesh);
                if (!isMobile) {
                    previewScene.remove(unit.previewMesh);
                }
            });
            units = [];
            
            // Clear particles
            particles.forEach(particle => scene.remove(particle));
            particles = [];
            
            // Clear dead units
            deadUnits.forEach(deadUnit => scene.remove(deadUnit.mesh));
            deadUnits = [];
            
            // Remove portal if exists
            if (portalMesh) {
                portalMesh.remove();
                portalMesh = null;
            }
            
            // Reset state but keep blood decals
            initialPositions.clear();
            gridHelper.visible = true;
        }

        function resetUnitsToInitialPositions() {
            units.forEach(unit => {
                if (initialPositions.has(unit)) {
                    unit.mesh.position.copy(initialPositions.get(unit));
                    unit.health = 100;
                    unit.target = null;
                    unit.speed = 0.2;
                    
                    // Safely reset material
                    if (Array.isArray(unit.mesh.material)) {
                        // If it's an array of materials (during battle)
                        unit.mesh.material.forEach(mat => {
                            if (mat) mat.color?.setHex(teamColors[unit.team]);
                        });
                    } else {
                        // If it's a single material (initial state)
                        unit.mesh.material.color?.setHex(teamColors[unit.team]);
                    }
                }
            });
            updatePreview();
        }

        function showEndScreen(title, message) {
            const endScreen = document.getElementById('endScreen');
            document.getElementById('endScreenTitle').textContent = title;
            if (message) {
                const messageElement = document.createElement('p');
                messageElement.textContent = message;
                endScreen.insertBefore(messageElement, endScreen.lastElementChild);
            }
            endScreen.style.display = 'block';
        }

        function closeEndScreen() {
            const endScreen = document.getElementById('endScreen');
            endScreen.style.display = 'none';
            // Remove any message paragraphs
            const messages = endScreen.getElementsByTagName('p');
            while (messages.length > 0) {
                messages[0].remove();
            }
        }

        function resetTeam() {
            const selectedTeam = parseInt(document.getElementById('teamSelect').value);
            const unitsToRemove = units.filter(unit => unit.team === selectedTeam);
            
            // Remove units from both main scene and preview
            unitsToRemove.forEach(unit => {
                scene.remove(unit.mesh);
                if (!isMobile) {
                    previewScene.remove(unit.previewMesh);
                }
            });
            
            // Update units array to keep only other teams
            units = units.filter(unit => unit.team !== selectedTeam);
            updatePreview();
        }

        function resetBattle() {
            units.forEach(unit => {
                scene.remove(unit.mesh);
                if (!isMobile) {
                    previewScene.remove(unit.previewMesh);
                }
            });
            units = [];
            isSimulating = false;
            document.getElementById('startButton').disabled = false;
            // Show grid on reset
            gridHelper.visible = true;
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (!isMobile) {
                updateCameraPosition();
            }
            
            // Update cloud animation with faster speeds
            clouds.forEach((cloud, index) => {
                const speed = 0.3 + (index % 3) * 0.1; // Increased base speed
                cloud.position.x += speed;
                if(cloud.position.x > GROUND_SIZE/2) {
                    cloud.position.x = -GROUND_SIZE/2;
                }
                // Add subtle vertical movement and rotation
                cloud.position.y += Math.sin(Date.now() * 0.001 + index) * 0.02;
                cloud.rotation.y += 0.001;
            });

            // Update dying units
            deadUnits.forEach((deadUnit, index) => {
                const elapsed = Date.now() - deadUnit.startTime;
                const progress = elapsed / DEATH_ANIMATION_DURATION;
                
                if (progress < 1) {
                    // Apply physics
                    deadUnit.mesh.position.add(deadUnit.mesh.userData.velocity);
                    deadUnit.mesh.userData.velocity.y -= 0.1; // gravity
                    deadUnit.mesh.rotation.x += deadUnit.mesh.userData.rotationVel.x;
                    deadUnit.mesh.rotation.y += deadUnit.mesh.userData.rotationVel.y;
                    deadUnit.mesh.rotation.z += deadUnit.mesh.userData.rotationVel.z;
                } else {
                    scene.remove(deadUnit.mesh);
                    deadUnits.splice(index, 1);
                }
            });
            
            // Update particles
            particles.forEach((particle, index) => {
                particle.position.add(particle.userData.velocity);
                particle.userData.life -= 0.02;
                particle.material.opacity = particle.userData.life;
                
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    particles.splice(index, 1);
                }
            });
            
            // Keep particle count in check
            while (particles.length > PARTICLE_COUNT) {
                const oldestParticle = particles.shift();
                scene.remove(oldestParticle);
            }

            if (isSimulating) {
                // Add random thunder strikes during battle
                const currentTime = Date.now();
                if (Math.random() < THUNDER_CHANCE && currentTime - lastThunderTime > THUNDER_COOLDOWN) {
                    // Pick random position near active units
                    const activeUnit = units.find(u => u.health > 0);
                    if (activeUnit) {
                        const randomOffset = new THREE.Vector3(
                            (Math.random() - 0.5) * 20,
                            0,
                            (Math.random() - 0.5) * 20
                        );
                        const strikePosition = activeUnit.mesh.position.clone().add(randomOffset);
                        createThunderEffect(strikePosition);
                        lastThunderTime = currentTime;
                    }
                }
                
                units.forEach(unit => unit.update());
                updatePreview();
                
                // Check for battle end
                const teamsAlive = new Set(units.filter(u => u.health > 0).map(u => u.team));
                if (teamsAlive.size <= 1) {
                    isSimulating = false;
                    document.getElementById('startButton').disabled = false;
                    document.getElementById('stopButton').disabled = false;
                    
                    // Switch back to calm music with crossfade
                    if (calmMusic && battleMusic) {
                        const fadeOut = setInterval(() => {
                            if (battleMusic.volume <= 0.1) {
                                clearInterval(fadeOut);
                                battleMusic.pause();
                                battleMusic.currentTime = 0;
                            } else {
                                battleMusic.volume -= 0.1;
                            }
                        }, 50);

                        calmMusic.volume = 0;
                        calmMusic.currentTime = 0;
                        calmMusic.play();
                        const fadeIn = setInterval(() => {
                            if (calmMusic.volume >= 0.9) {
                                clearInterval(fadeIn);
                                calmMusic.volume = 1;
                            } else {
                                calmMusic.volume += 0.1;
                            }
                        }, 50);
                    }

                    const actualWinner = window.predeterminedWinner;
                    showEndScreen('Battle Ended', `${teamNames[actualWinner]} wins!`);
                    
                    // Clear everything except blood decals
                    clearBattleField();
                }
            }

            // Update portal if it exists
            if (portalMesh) {
                portalMesh.update();
            }

            controls.update();
            renderer.render(scene, camera);
            if (!isMobile) {
                previewRenderer.render(previewScene, previewCamera);
            }
        }

        initializeEnv();

        if (isMobile) {
            // Prevent zoom on input focus
            document.querySelectorAll('input, select').forEach(element => {
                element.addEventListener('focus', () => {
                    // Save current camera position
                    const savedPos = camera.position.clone();
                    const savedZoom = controls.target.clone();
                    
                    element.addEventListener('blur', () => {
                        // Restore camera position after slight delay
                        setTimeout(() => {
                            camera.position.copy(savedPos);
                            controls.target.copy(savedZoom);
                            controls.update();
                        }, 300);
                    }, { once: true });
                });
            });

            // Simplify button handling for mobile
            document.querySelectorAll('button').forEach(button => {
                button.addEventListener('touchstart', function(e) {
                    e.stopPropagation();
                    // Call the function directly based on button's onclick attribute
                    const onclickAttr = this.getAttribute('onclick');
                    if (onclickAttr) {
                        // Execute the function directly
                        window[onclickAttr.replace('()', '')]();
                    }
                }, { passive: true });
            });

            // Only prevent default on canvas touches
            window.addEventListener('touchstart', (e) => {
                if (e.target.tagName === 'CANVAS' && !isSimulating) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                    placeUnits();
                }
            }, { passive: false });
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Only check screen size changes if not focused on input
            if (document.activeElement.tagName !== 'INPUT' && 
                document.activeElement.tagName !== 'TEXTAREA') {
                const wasMobile = isMobile;
                const newIsMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
                
                if (wasMobile !== newIsMobile) {
                    location.reload();
                }
            }
        });
    </script>
</body>
</html>
